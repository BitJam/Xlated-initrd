#!/live/bin/sh

### BEGIN INIT INFO
# Provides:          live-usb-save
# Required-Start:
# Required-Stop:
# Should-Start:
# Default-Start:     3 4 5
# Default-Stop:      0 1 6
# Short-Description:
# Description:       save/restore some information on raw liveusb w/o persistence
### END INIT INFO

STATE_FILES="
/var/lib/alsa/asound.state
"

STATE_FILES_FILE="/etc/live/state-files"

 STATE_DIR=state/mach
USTATE_DIR=state/user

ID_DIR="/sys/class/dmi/id"
ID_FILES="board_vendor board_name board_version"

DS_FILE="/home/%s/.desktop-session/default-desktop"

export PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin

. /live/lib/live-init-utils.sh

. $INITRD_OUT

start_init_logging
load_translation

main() {
    case $1 in
        start) do_start   ;;
         stop) do_stop    ;;
            *) echo "Usage: $0 {start|stop}" ;;
    esac
    exit 0
}

do_start() {

    test -e /live/config/remasterable || exit 0
    echo_script "$_Restore_state_information_" $0
    read_cmdline

    if test -r $STATE_FILES_FILE; then
        STATE_FILES=$(cat $STATE_FILES_FILE 2>/dev/null)
    else
        echo_cmd mkdir -p $(dirname $STATE_FILES_FILE)
        echo "$STATE_FILES" > $STATE_FILES_FILE
    fi

    local bdir root_dir 
    for bdir in $SQFILE_DIR $TORAM_MP; do
        [ -d $bdir ] || continue
        root_dir=$bdir
        break
    done

    [ "$root_dir" ] || exit 0

    restore_mach_state $root_dir/$STATE_DIR
    restore_desktop    $root_dir/$USTATE_DIR
}

do_stop() {

    test -e /live/config/remasterable || exit 0
    echo_script "$_Save_state_information_" $0
    read_cmdline

    local root_dir=$SQFILE_DIR
    if [ "$DID_TORAM" ]; then

        if [ -z "$BOOT_UUID" ; then
            echo_live "$_Could_not_find_UUID_of_boot_device_for_remounting_"
            echo_live "$_Will_not_save_state_information_"
            return
        fi

        echo_cmd mkdir -p $BOOT_MP
        if ! mount -U $BOOT_UUID $BOOT_MP; then
            echo_live "$_Could_not_remount_boot_device_"
            echo_live "$_Will_not_save_state_information_"
            return
        fi
    fi

    test -r $STATE_FILES_FILE && STATE_FILES=$(cat $STATE_FILES_FILE 2>/dev/null)

    save_mach_state $root_dir/$STATE_DIR
    save_desktop    $root_dir/$USTATE_DIR
}

save_desktop() {
    local to_dir=$1

    local user from to
    for user in $(ls /home); do
        from=$(printf $DS_FILE $user)
        [ -e "$from" ] || continue
        to="$to_dir/$user/default-desktop"
        should_copy "$from" "$to" || continue
        echo_live "$_Save_X_desktop_Y_" $(pquote $user) $(pquote $(cat $from))
        echo_cmd mkdir -p $(dirname "$to")
        echo_cmd cp "$from" "$to"
    done
}

restore_desktop() {
    local from_dir=$1

    # There are many reasons to not restore
    [ "$CMD_DESKTOP" ] && return
    [ "$PERSISTENCE" ] && return

    local user dest_dir dest sorc
    for user in $(ls $from_dir 2>/dev/null); do
        sorc=$from_dir/$user/default-desktop
        dest=$(printf $DS_FILE $user)
        dest_dir=$(dirname $dest)
        [ -d "$dest_dir" ] || continue
        [ -e "$sorc"     ] || continue
        should_copy $sorc $dest || continue
        echo_live "$_restore_X_desktop_to_Y_" $(pquote $user) $(pquote $(cat $sorc))
        echo_cmd cp "$sorc" "$dest"
        echo_cmd chown $user:users $dest
    done
}

save_mach_state() {
    local mach_dir=$1/$(mach_id)  file

    if ! test -e $mach_dir; then
        echo_cmd mkdir -p $mach_dir
        for file in $ID_FILES; do
            echo_cmd cp $ID_DIR/$file $mach_dir
        done
    fi

    # Save system files under mach_dir
    for file in $(state_files); do
        [ -z "${file###*}" ] && continue
        local from=$file
        local to=$mach_dir$file
        should_copy $from $to || continue
        echo_live "$_save_state_file_X_" $(pquote $file)
        echo_cmd mkdir -p $(dirname $to)
        echo_cmd cp $from $to
    done
}

restore_mach_state() {
    local mach_dir=$1/$(mach_id)  file

    if test -e $mach_dir; then
        # Copy saved state files to system
        for file in $(state_files); do
            local from=$mach_dir/$file
            local to=$file
            should_copy $from $to || continue
            echo_live "$_restore_state_file_X_" $(pquote $file)
            echo_cmd mkdir -p $(dirname $to)
            echo_cmd cp $from $to
        done
    else
        # Delete state files on a "new" machine
        for file in $STATE_FILES; do
            test -e $file || continue
            echo_live "$_delete_state_file_X_" $(pquote $file)
            echo_cmd rm -f $file
        done
    fi
}

read_cmdline() {
    CMDLINE=$(cat /proc/cmdline /live/config/cmdline)
    local param
    for param in $CMDLINE; do
        value=${param#*=}
        case $param in
           nousbstate)  exit 0 ;;
            desktop=*)  CMD_DESKTOP=$value ;;
        esac
    done
}

should_copy() {
    local from="$1"  to="$2"
    [ -e "$from" ] || return 1
    [ -e "$to"   ] || return 0
    diff -q "$from" "$to" 1>/dev/null 2>/dev/null && return 1
    return 0
}

mach_id() { cat $ID_DIR/board_* | md5sum | cut -d" " -f1 ;}
state_files() { echo "$STATE_FILES" | grep -v "^\s*#" | sed "s/\s*#.*//" ;}

# For early testing
echo_cmd() { "$@" ;}

main "$@"

