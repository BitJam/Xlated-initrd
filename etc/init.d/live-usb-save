#!/live/bin/sh

### BEGIN INIT INFO
# Provides:          live-usb-save
# Required-Start:
# Required-Stop:
# Should-Start:
# Default-Start:     3 4 5
# Default-Stop:      0 1 6
# Short-Description:
# Description:       save/restore some information on raw liveusb w/o persistence
### END INIT INFO

MSTATE_FILES="
    /var/lib/alsa/asound.state
"
GSTATE_FILES="
    /var/lib/wicd/configuration/*
    /etc/wicd/*.conf
    /etc/NetworkManager/system-connections/*
    /etc/network/interfaces 
    /etc/network/interfaces.d/*
"

MSTATE_FILES_FILE="/etc/live/config/machine-state-files"
GSTATE_FILES_FILE="/etc/live/config/general-state-files"
    NO_STATE_FILE="/etc/live/config/no-state"

MSTATE_DIR=state/machine
GSTATE_DIR=state/general
USTATE_DIR=state/user

ID_DIR="/sys/class/dmi/id"
ID_FILES="board_vendor board_name board_version"

DS_FILE="/home/%s/.desktop-session/default-desktop"

export PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin

. /live/lib/live-init-utils.sh

. $INITRD_OUT

start_init_logging
load_translation

main() {
    case $1 in
        start) do_start   ;;
         stop) do_stop    ;;
            *) echo "Usage: $0 {start|stop}" ;;
    esac
    exit 0
}

do_start() {

    test -e /live/config/remasterable || exit 0
    test -e $NO_STATE_FILE            && exit 0
    read_cmdline

    local bdir root_dir
    for bdir in $SQFILE_DIR $TORAM_MP; do
        [ -d $bdir ] || continue
        root_dir=$bdir
        break
    done

    [ "$root_dir" ] || exit 0
    test -e $root_dir/state/no-state && exit 0

    # Create default config file if it doesn't already exist
    if test -r $MSTATE_FILES_FILE; then
        MSTATE_FILES=$(cat $MSTATE_FILES_FILE 2>/dev/null)
    else
        echo_cmd mkdir -p $(dirname $MSTATE_FILES_FILE)
        echo "$MSTATE_FILES" > $MSTATE_FILES_FILE
    fi

    echo_script "$_Restore_state_information_" $0

    # Always restore machine specific state files
    restore_state   $root_dir/$MSTATE_DIR $(mach_id) "$(state_files "$MSTATE_FILES")"

    # Only restore general state files and user files if root persistence is not
    # enabled
    test -e $root_dir/config/persist-root && return

    # Create default config file if it doesn't already exist
    if test -r $GSTATE_FILES_FILE; then
        GSTATE_FILES=$(cat $GSTATE_FILES_FILE 2>/dev/null)
    else
        echo_cmd mkdir -p $(dirname $GSTATE_FILES_FILE)
        echo "$GSTATE_FILES" > $GSTATE_FILES_FILE
    fi

    restore_state   $root_dir/$GSTATE_DIR ""         "$(state_files "$GSTATE_FILES")"

    [ "$PERSISTENCE" ] && return

    restore_desktop $root_dir/$USTATE_DIR
}

do_stop() {

    test -e /live/config/remasterable || exit 0
    test -e $NO_STATE_FILE            && exit 0
    read_cmdline

    local root_dir=$SQFILE_DIR
    if [ "$DID_TORAM" ]; then

        if [ -z "$BOOT_UUID" ]; then
            echo_live "$_Could_not_find_UUID_of_boot_device_for_remounting_"
            echo_live "$_Will_not_save_state_information_"
            return
        fi

        echo_cmd mkdir -p $BOOT_MP
        if ! mount -U $BOOT_UUID $BOOT_MP; then
            echo_live "$_Could_not_remount_boot_device_"
            echo_live "$_Will_not_save_state_information_"
            return
        fi
    fi

    test -e $root_dir/state/no-state && exit 0

    test -r $MSTATE_FILES_FILE && MSTATE_FILES=$(cat $MSTATE_FILES_FILE 2>/dev/null)
    test -r $GSTATE_FILES_FILE && GSTATE_FILES=$(cat $GSTATE_FILES_FILE 2>/dev/null)

    echo_script "$_Save_state_information_" $0

    save_desktop $root_dir/$USTATE_DIR
    save_state   $root_dir/$MSTATE_DIR $(mach_id) "$(state_files "$MSTATE_FILES")"
    save_state   $root_dir/$GSTATE_DIR ""         "$(state_files "$GSTATE_FILES")"
}

save_desktop() {
    local to_dir=$1

    test -e $to_dir/no-state && return

    local user from to
    for user in $(ls /home); do
        from=$(printf $DS_FILE $user)
        [ -e "$from" ] || continue
        to="$to_dir/$user/default-desktop"
        should_copy "$from" "$to" || continue
        echo_live "$_Save_X_desktop_Y_" $(pquote $user) $(pquote $(cat $from))
        echo_cmd mkdir -p $(dirname "$to")
        echo_cmd cp "$from" "$to"
    done
}

restore_desktop() {
    local from_dir="$1"

    # There are many reasons to not restore
    [ "$CMD_DESKTOP" ] && return

    test -e $from_dir/no-state && return

    local user dest_dir dest sorc
    for user in $(ls $from_dir 2>/dev/null); do
        sorc=$from_dir/$user/default-desktop
        dest=$(printf $DS_FILE $user)
        dest_dir=$(dirname $dest)
        [ -d "$dest_dir" ] || continue
        [ -e "$sorc"     ] || continue
        should_copy $sorc $dest || continue
        echo_live "$_restore_X_desktop_to_Y_" $(pquote $user) $(pquote $(cat $sorc))
        echo_cmd cp "$sorc" "$dest"
        echo_cmd chown $user:users $dest
    done
}

save_state() {
    local state_dir="$1" dir2="$2" files="$3"
    test -e $state_dir/no-state && return

    state_dir=$state_dir${dir2:+/$dir2}

    if ! test -e $state_dir; then
        echo_cmd mkdir -p $state_dir
        if [ "$dir2" ]; then
            for file in $ID_FILES; do
                echo_cmd cp $ID_DIR/$file $state_dir
            done
        fi
    fi

    # Save system files under state_dir
    local file
    for file in $files; do
        local from=$file
        local to=$state_dir/files$file
        should_copy $from $to || continue
        echo_live "$_save_state_file_X_" $(pquote $file)
        echo_cmd mkdir -p $(dirname $to)
        echo_cmd cp $from $to
    done
}

restore_state() {
    local state_dir="$1" dir2="$2" files="$3"
    test -e $state_dir/no-state && return

    state_dir=$state_dir${dir2:+/$dir2}

    if test -e $state_dir; then
        # Copy saved state files to system
        for from in $(find $state_dir/files -type f 2>/dev/null); do
            local to=${from#$state_dir/files}
            should_copy $from $to || continue
            echo_live "$_restore_state_file_X_" $(pquote $to)
            echo_cmd mkdir -p $(dirname $to)
            echo_cmd cp $from $to
        done
    else
        [ "$dir2" ] || return
        # Delete machine-specific state files on a "new" machine
        for file in $MSTATE_FILES; do
            test -f $file || continue
            echo_live "$_delete_state_file_X_" $(pquote $file)
            echo_cmd rm -f $file
        done
    fi
}

read_cmdline() {
    CMDLINE=$(cat /proc/cmdline /live/config/cmdline)
    local param
    for param in $CMDLINE; do
        value=${param#*=}
        case $param in
           nousbstate)  exit 0 ;;
           dbusbstate)  DB_USB_STATE=true;;
            desktop=*)  CMD_DESKTOP=$value ;;
        esac
    done
}

should_copy() {
    local from="$1"  to="$2"
    [ -f "$from" ] || return 1
    [ -e "$to"   ] || return 0
    diff -q "$from" "$to" 1>/dev/null 2>/dev/null && return 1
    return 0
}

mach_id() { cat $ID_DIR/board_* | md5sum | cut -d" " -f1 ;}
state_files() { echo "$1" | grep -v "^\s*#" | sed "s/\s*#.*//" ;}

# For testing
echo_cmd() { 
    [ "$DB_USB_STATE" ] && echo "$@"
    "$@"
}

main "$@" 2>&1 | tee -a $INIT_LOG_FILE
