#!/live/bin/sh

### BEGIN INIT INFO
# Provides:         live-vcard-menu
# Required-Start:
# Required-Stop:
# Should-Start:
# Should-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: present menu to select a video card
# Description:       present menu to select a video card
### END INIT INFO


export PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin:/live/bin

test -d /live/config/tsplash && DO_TSPLASH=true

vcard_conf_file=/live/config/vcard-menu
XORG_BUS_ID_FILE="/etc/X11/xorg-bus-id"

. /live/lib/live-init-utils.sh
start_init_logging
# FIXME: load_translation

bar80="--------------------------------------------------------------------------------"

main() {
    case $1 in
        start) do_start  ;;
         stop)           ;;
            *)  echo "Usage: $0 {start|stop}" ;  exit 1 ;;
    esac
}

do_start() {

    local mode=$(cat $vcard_conf_file 2>/dev/null)
    # sanity check
    case $mode in
          ""|off) return         ;;
              on)                ;;
           force) FORCE=true     ;;

               *) echo_live "Uknown vcard_menu mode %s" "$(pquote "$mode")"
                          return ;;
    esac

    echo_script "Video card selection menu" $0

    local LSPCI_GRAPHICS=$(lspci_graphics)
    local card_cnt=$(echo "$LSPCI_GRAPHICS" | wc -l)

    case $card_cnt in
        0) echo_live "No video cards found" ; return ;;
        1) force || return                           ;;
    esac

    local card_id  bus_id=$(cat $XORG_BUS_ID_FILE 2>/dev/null)

    if [ -n "$bus_id" ]; then
        id_card=$(get_card "$bus_id")

        if [ -z "$id_card" ]; then
            echo_live "Found bus-id %s but did not find associated card" "$(pquote $bus_id)"
        else
            echo_live "Currently selected video card"
            echo_live '  %s' "$(pquote "$id_card")"

            XORG_BUS_ID=$bus_id
        fi
    fi

    # Don't run menu if we already created a valid xorg-bus-id file
    ! force && [ -n "$XORG_BUS_ID" ] && return
    set_colors

    echo
    [ "$DO_TSPLASH" ] && tsplash_clear
    echo "$m_co$bar80$nc_co"

    video_card_menu "$LSPCI_GRAPHICS"

    local new_card=$(get_card "$NEW_BUS_ID")
    if [ -n "$new_card" ]; then
        echo_live "Newly selected video card"
        echo_live '  %s' "$(pquote "$new_card")"
    fi

    #. the "Enter" key
    local enter="Enter"

    #. Press <Enter> to continue
    local prompt=$(printf "Press <%s> to continue" "$(cq "$enter")")

    printf "$m_co%s$nc_co" "$prompt"

    local xxx
    read xxx

    echo
    echo "$m_co$bar80$nc_co"
    echo

    if [ "$DO_TSPLASH" ]; then
        #/live/bin/tell-tsplash alert "$(printf "Using card %s" "$new_card")"
        tsplash-on
    fi

    [ "$NEW_BUS_ID" = "$XORG_BUS_ID" ] && return

    # Send it as a cmdline parameter to live-init
    echo "xorg=busid=$NEW_BUS_ID" >> /live/config/cmdline2
}

#------------------------------------------------------------------------------
# Select a video card bus_id based on the names
#------------------------------------------------------------------------------
video_card_menu() {
    local card_cnt=$(echo "$LSPCI_GRAPHICS" | wc -l)

    case $card_cnt in
        0) say "No video cards found"      ; return ;;
        #1) say "Only one video card found" ; return ;;
    esac

    local disp_fmt="$green %2s)$m_co %s$nc_co"
    local cnt=1  bus_id  text  data  disp
    while read bus_id text; do
        [ -z "$bus_id" ] && continue
        data="${data}$cnt:$bus_id\n"
        disp="${disp}$(printf "$disp_fmt" "$cnt" "$text")\n"
        cnt=$((cnt + 1))
        # echo "id: $id   text: $text"
    done<<Lspci_nn
$(munge_lspci "$LSPCI_GRAPHICS")
Lspci_nn

    data="${data}0:quit\n"
    disp="$disp$(printf "$disp_fmt" "0" "quit")\n"

    local new_bus_id  title="Please select a video card to use"
    my_select_2 "$title" new_bus_id "0" "$data" "$disp"

    if [ "$new_bus_id" = "quit" ]; then
        say "Not selecting a video card"
        return
    fi
    NEW_BUS_ID=$new_bus_id
}

#------------------------------------------------------------------------------
# Remove class description, shorten some of the text, and removed the pci-id
#------------------------------------------------------------------------------
munge_lspci() {
    echo "$1" | sed -r -n "s/^([0-9a-f:.]+) [^:]+: /\1 /pi"  | shorten_lspci
 }

shorten_lspci() {
    sed -r -e "s/Advanced Micro Devices, Inc\./AMD/" \
        -e "s/ \[AMD\/ATI\]//" -e "s/\[AMD\]//" \
        -e "s/(NVIDIA|Intel) Corporation/\1/" \
        -e "s/ \[[0-9a-f]{4}:[0-9a-f]{4}\]//i"
}

#------------------------------------------------------------------------------
# Find the text description of a pci card based on the bus id
#------------------------------------------------------------------------------
get_card() {
    local bus_id=$1
    echo "$LSPCI_GRAPHICS" | sed -n "s/^$bus_id //p" \
        | sed -r "s/^[^:]*: //" | shorten_lspci
}

#------------------------------------------------------------------------------
# Run lspci with then 4 different graphics classes.  For my slow code that
# gets the graphics drivers this provides a big speed-up.
#------------------------------------------------------------------------------
lspci_graphics() {
    #lspci "$@"
    lspci -D -d::0300 "$@"
    lspci -D -d::0301 "$@"
    lspci -D -d::0302 "$@"
    lspci -D -d::0390 "$@"
}

#==============================================================================
# Code below taken from select-device-2 test script
#==============================================================================

#------------------------------------------------------------------------------
# my_select_2  title variable name default-entry-# data display
#  "data" is $:value.  Display is whatever gets displayed
#------------------------------------------------------------------------------
my_select_2() {
    local title=$1  var=$2  default=$3  data=$4  display=$5  enter="Enter"
    local def_prompt=$(printf "Press <%s> for the default selection" "$(cq "$enter")")

    local val input err_msg
    while [ -z "$val" ]; do

        echo -e "$hi_co$title$nc_co"
        printf "$display" | sed -r -e "s/(^|\t)( ?[0-9]+)(\))/\t$green\2$white\3$cyan/g" -e "s/$/$nc_co/"
        [ "$err_msg" ] && printf "$err_co%s$nc_co\n" "$err_msg"
        [ "$default" ] && printf "$m_co%s$nc_co\n" "$def_prompt"
        echo -n "$green>$nc_co "

        #return

        read input
        err_msg=
        [ -z "$input" -a -n "$default" ] && input=$default

        if ! echo "$input" | grep -q "^[0-9]\+$"; then
            err_msg="You must enter a number"
            [ "$default" ] && err_msg="You must enter a number or press <enter>"
            continue
        fi

        val=$(echo -e "$data" | sed -n "s/^$input://p")

        if [ -z "$val" ]; then
            err_msg=$(printf "The number <%s> is out of range" "$(pqe $input)")
            continue
        fi

        eval $var=\$val
        break
    done
}


db_msg() { vmsg 5 "${green}db+:$hi_co $@" ;}
err()    { vmsg 1 "$err_co$@"             ;}
msg()    { vmsg 5 "$@"                    ;}
msgN()   { vmsgN 5 "$@"                   ;}
msg_nc() { vmsg 5 "$nc_co$@"              ;}
warn()   { vmsg 3 "$warn_co$@"            ;}

bq()     { echo "$yellow$*$m_co"          ;}
cq()     { echo "$cheat_co$*$m_co"        ;}
cqw()    { echo "$cheat_co$*$warn_co"     ;}
cqe()    { echo "$cheat_co$*$err_co"      ;}
dq()     { echo "$dev_co$*$m_co"          ;}
dqe()    { echo "$dev_co$*$err_co"        ;}
fq()     { echo "$from_co$*$m_co"         ;}
fqe()    { echo "$from_co$*$err_co"       ;}
mpq()    { echo "$mp_co$*$m_co"           ;}
nq()     { echo "$num_co$*$m_co"          ;}
nqw()    { echo "$num_co$*$warn_co"       ;}
pq()     { echo "$hi_co$*$m_co"           ;}
pqe()    { echo "$bold_co$*$err_co"       ;}
pqw()    { echo "$hi_co$*$warn_co"        ;}
pqh()    { echo "$m_co$*$hi_co"           ;}
hq()     { echo "$hi_co$*$m_co"           ;}

vmsg() {
    local level=$1  fmt=$2
    shift 2

    msg=$(printf "$m_co$fmt$nc_co" "$@")

    [ "$level" -le "$VERBOSE" ] && printf "$msg\n"
    echo -e "$msg" >> $MY_LOG
    return 0
}

fatal() {
    local fmt=$1 ; shift
    printf "ERROR: $fmt\n" "$@" >&2
    exit 3
}

vmsgN() {
    local level=$1  fmt=$2
    shift 2

    msg=$(printf "$m_co$fmt$nc_co" "$@")

    [ "$level" -le "$VERBOSE" ] && printf "$msg"
    echo -ne "$msg" >> $MY_LOG
    return 0
}

vmsg_if() {
    local level=$1; shift
    [ "$VERBOSE" -ge "$level" ] || return
    vmsg $level "$@"
}

vmsg_nc() {
    local level=$1; shift
    vmsg $level "$nc_co$@"
}

say() {
    local fmt=$1 ; shift
    printf "$m_co$fmt$nc_co\n" "$@"
}

set_colors() {
    local noco=$1  loco=$2

    [ "$noco" ] && return

    local e=$(printf "\e")
     black="$e[0;30m";    blue="$e[0;34m";    green="$e[0;32m";    cyan="$e[0;36m";
       red="$e[0;31m";  purple="$e[0;35m";    brown="$e[0;33m"; lt_gray="$e[0;37m";
   dk_gray="$e[1;30m"; lt_blue="$e[1;34m"; lt_green="$e[1;32m"; lt_cyan="$e[1;36m";
    lt_red="$e[1;31m"; magenta="$e[1;35m";   yellow="$e[1;33m";   white="$e[1;37m";
     nc_co="$e[0m";

    cheat_co=$white;      err_co=$red;       hi_co=$white;
      cmd_co=$white;     from_co=$lt_green;  mp_co=$magenta;   num_co=$magenta;
      dev_co=$magenta;   head_co=$yellow;     m_co=$lt_cyan;    ok_co=$lt_green;
       to_co=$lt_green;  warn_co=$yellow;  bold_co=$yellow;

    [ "$loco" ] || return

    from_co=$brown
      hi_co=$white
       m_co=$nc_co
     num_co=$white
}

tsplash_clear() {
    [ "$DO_TSPLASH" ] || return

    if [ -z "$TSPLASH_CLEARED" ]; then
        clear
        sleep .2
        TSPLASH_CLEARED=true
    fi
    chvt 1
}

force() { [ "$FORCE" ] ; return $?; }

main "$@" 2>&1 | tee -a $INIT_LOG_FILE

exit 0
